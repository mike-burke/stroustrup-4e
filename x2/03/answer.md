_Write an essay: What can a good programming language do for you and what canâ€™t you expect it to help with?_

Programming software is vital to a broad range of industries, environments and purposes; it is also a deeply human activity. A good programming language should first and foremost support the humans writing and maintaining it while delivering maximum flexibility and minimizing constraints around how and where that software operates. Conversely, no language can anticipate all possible problems or ways of writing software. Software always involves human judgement, so no programming language can prevent poor quality code resulting from choices in naming or structure; nor can it prevent misuse of features that introduce functional, performance or stability issues.

Any meaningful software system will involve more time spent in maintenance than up-front code authoring. A language that allows enginers to structure their code in a way that models the problem space and 'business domain' is best placed to support this work. Particularly, the ability to create new types and structures that are intrinsically integrated into the rest of the language is an important aspect; the 'code as written' should map naturally and intuitively to the problem being solved; this will support faster reasoning about existing code and reduce the effort and risk associated with changes.

Supporting human productivity is a second important aspect of a good programminglanguage. This can be supported through the use of libraries to maximize reuse and ensure that work is focused on differentiated, unsolved problems. In addition, a language that allows engineers to ramp up their use of features (and the complexity of problems solved) over time ensures a smoother learning curve and enables individuals to build familiarity and proficiency in a structured way. 

Computer runtimes and hardware change faster than the software that runs on them. A language that provides code portability to different hardware types ensures maximum return on investment and gives teams building the software greater choice around the hardware they target. Sometimes, being able to fully exploit the hardware being used is more important than portability; not everything can be covered through standard, portable APIs. It's important for a language to allow access to those featuers where needed, rather than 'hide' them from the engineer or create a lowest-common-denominator effect.

Even the best programming language cannot be all things to all people. Even the largest standard library is incapable of addressing all possible needs in all possible domains; the language should instead focus on supporting the creation of portable libraries that can be reused. Programming styles and fashions come and go - procedural, object-oriented, aspect-oriented and functional styles are some examples - but it is not reasonable or sensible for a single language to be 'great' at all possible styles - while it is possible for a language to introduce syntax to support new styles, this will ultimately come at the cost of cohesion and comprehension for the humans writing and maintaining the software. 

While a language cannot solve all problems through pre-defined libraries, it also cannot provide single answers to a given problem. Context is critical - a container that provides strong lookup performance but poor insert performance will make sense in some scenarios but not others; ultimately choices must be provided so that engineers can make the right decision for their situation. It follows that a programming language cannot prevent misuse of libraries or featuers resulting from poor judgement or understanding. 

Finally, there are other aspects to writing software that will always remain the repsonsibility of the the engineer - naming and structure. The use of accurate, intuitive and succinct names is vital to ensuring understandable (and maintainable) software; a programming language can establish norms through standard libraries, but cannot enforce 'good' naming. Similarly, there will always be choices around how to structure code - in C++, an engineer may choose to implement a single function, a class heirachy, or a template combinining both aspects - all choices can produce working, performant code, but each choice will result in vastly different structures and may introduce accidental complexity ('spaghetti code').  

A good programming language can equip good programmers to write clear, maintainable and efficient software that is capable of running in a wide range of environments and can fully exploit the underlying hardware. To deliver those outcomes, it must also provide choices - this means that bad choices can be made that result in poor quality software. Ultimately, engineer judgement and experience is crucial to the creation of any successful, complex software system.
